--- test_edge_cases.py	(revision Before)
+++ test_edge_cases.py
@@ -1,213 +0,0 @@
-import os
-import tempfile
-from pathlib import Path
-
-from serena.tools.file_tools import ReplaceRegexTool
-
-# Mock classes needed for testing
-class MockProject:
-    def __init__(self, root_dir):
-        self.root_dir = root_dir
-        self.project_root = root_dir
-        self.project_config = MockProjectConfig()
-
-    def validate_relative_path(self, path):
-        return True
-
-    def read_file(self, path):
-        with open(os.path.join(self.root_dir, path), 'r') as f:
-            return f.read()
-
-    def is_ignored_path(self, path):
-        return False
-        
-class MockProjectConfig:
-    def __init__(self):
-        self.encoding = 'utf-8'
-
-class MockAgent:
-    def __init__(self, project):
-        self.project = project
-        self._active_project = project
-        self.lines_read = None
-        self.serena_config = None
-        
-    def get_active_project_or_raise(self):
-        return self.project
-        
-    def get_active_project(self):
-        return self.project
-        
-    def is_using_language_server(self):
-        return False
-        
-    def record_tool_usage_if_enabled(self, *args, **kwargs):
-        pass
-        
-    def issue_task(self, task, name):
-        from concurrent.futures import Future
-        future = Future()
-        future.set_result(task())
-        return future
-
-# Create a temporary directory for testing
-with tempfile.TemporaryDirectory() as temp_dir:
-    # Setup mock project and agent
-    project = MockProject(temp_dir)
-    agent = MockAgent(project)
-    
-    # Create the tool
-    tool = ReplaceRegexTool(agent)
-    
-    # Test various edge cases
-    test_cases = [
-        {
-            "name": "Test 1: Basic newline escape sequence",
-            "content": "print('Hello')",
-            "regex": r"print\('Hello'\)",
-            "repl": r"print(f'\n    World')",
-            "expected_contains": r"print(f'\\n    World')",
-            "expected_not_contains": r"print(f'\n"
-        },
-        {
-            "name": "Test 2: Already escaped newline",
-            "content": "print('Hello')",
-            "regex": r"print\('Hello'\)",
-            "repl": r"print(f'\\n    World')",
-            "expected_contains": r"print(f'\\n    World')",
-            "expected_not_contains": r"print(f'\n"
-        },
-        {
-            "name": "Test 3: Double escaped newline",
-            "content": "print('Hello')",
-            "regex": r"print\('Hello'\)",
-            "repl": r"print(f'\\\\n    World')",
-            "expected_contains": r"print(f'\\\\n    World')",
-            "expected_not_contains": r"print(f'\n"
-        },
-        {
-            "name": "Test 4: Mixed escape sequences",
-            "content": "print('Hello')",
-            "regex": r"print\('Hello'\)",
-            "repl": r"print(f'\n\t    World\r\n')",
-            "expected_contains": r"print(f'\\n\\t    World\\r\\n')",
-            "expected_not_contains": r"print(f'\n"
-        },
-        {
-            "name": "Test 5: Newline in JSON string format",
-            "content": "print('Hello')",
-            "regex": r"print\('Hello'\)",
-            "repl": "print(f'\\n    World')",
-            "expected_contains": r"print(f'\\n    World')",
-            "expected_not_contains": r"print(f'\n"
-        },
-        {
-            "name": "Test 6: Literal newline in string",
-            "content": "print('Hello')",
-            "regex": r"print\('Hello'\)",
-            "repl": "print(f'\n    World')",
-            "expected_contains": r"print(f'\\n    World')",
-            "expected_not_contains": r"print(f'\n"
-        },
-        {
-            "name": "Test 7: Multiple newlines in complex string",
-            "content": "print('Hello')",
-            "regex": r"print\('Hello'\)",
-            "repl": "if (condition) {\n    print('Line 1');\n    print('Line 2');\n}",
-            "expected_contains": "if (condition) {",
-            "expected_not_contains": None  # We expect literal newlines in this case
-        },
-        {
-            "name": "Test 8: Newline in f-string with indentation",
-            "content": "                  print(f'Some text')",
-            "regex": r"print\(f'Some text'\)",
-            "repl": r"print(f'\n   Confidence Calculation Breakdown:')",
-            "expected_contains": r"print(f'\\n   Confidence Calculation Breakdown:')",
-            "expected_not_contains": r"print(f'\n"
-        },
-        {
-            "name": "Test 9: Exact scenario from issue description",
-            "content": "    *this >> wTag;",
-            "regex": r"\*this >> wTag;",
-            "repl": """    // Get file position BEFORE reading
-    long preReadPos = -1;
-    if (m_pFile) {
-        preReadPos = m_pFile->GetPosition();
-    }
-    *this >> wTag;
-    fprintf(stderr, "DEBUG: ReadClass at file pos 0x%lX, read wTag=0x%04X\\n", preReadPos, wTag);""",
-            "expected_contains": "DEBUG: ReadClass at file pos",
-            "expected_not_contains": None  # We expect literal newlines in this case
-        }
-    ]
-    
-    for i, test_case in enumerate(test_cases):
-        # Create a test file
-        test_file = os.path.join(temp_dir, f"test_file_{i}.txt")
-        with open(test_file, "w") as f:
-            f.write(test_case["content"])
-        
-        # Print the replacement string for debugging
-        print(f"Replacement string (repr): {repr(test_case['repl'])}")
-        print(f"Replacement string (bytes): {test_case['repl'].encode()}")
-        
-        # Apply the replacement
-        result = tool.apply(
-            relative_path=f"test_file_{i}.txt",
-            regex=test_case["regex"],
-            repl=test_case["repl"],
-        )
-        
-        # Read the file and check the content
-        with open(test_file, "r") as f:
-            content = f.read()
-        
-        # Read the file as bytes to see the exact byte representation
-        with open(test_file, "rb") as f:
-            content_bytes = f.read()
-        
-        print(f"\n{test_case['name']}")
-        print(f"Result: {result}")
-        print(f"Content (repr): {repr(content)}")
-        print(f"Content (bytes): {content_bytes}")
-        
-        # For string tests, check if there's a literal newline in the string
-        if "print(f'" in content:
-            # Find the position of the opening quote
-            start_pos = content.find("print(f'") + len("print(f'")
-            # Find the position of the closing quote
-            end_pos = content.find("')", start_pos)
-            # Extract the string content
-            string_content = content[start_pos:end_pos]
-            print(f"String content: {repr(string_content)}")
-            
-            # Check if there's a literal newline in the string
-            if "\n" in string_content:
-                print("❌ ISSUE DETECTED: String contains literal newline!")
-            else:
-                print("✅ String does not contain literal newline.")
-        
-        # Check if the content contains the expected string
-        if test_case["expected_contains"]:
-            if test_case["expected_contains"] in content:
-                print(f"✅ Content contains expected string: {test_case['expected_contains']}")
-            else:
-                print(f"❌ Content does NOT contain expected string: {test_case['expected_contains']}")
-                # Try to find a similar string
-                for i in range(len(content) - 5):
-                    if content[i:i+5] in test_case["expected_contains"]:
-                        print(f"  Found partial match: {repr(content[i:i+20])}")
-                        break
-        
-        # Check if the content does not contain the unexpected string
-        if test_case["expected_not_contains"]:
-            if test_case["expected_not_contains"] not in content:
-                print(f"✅ Content does NOT contain unexpected string: {test_case['expected_not_contains']}")
-            else:
-                print(f"❌ Content contains unexpected string: {test_case['expected_not_contains']}")
-                # Show the context around the unexpected string
-                pos = content.find(test_case["expected_not_contains"])
-                if pos >= 0:
-                    start = max(0, pos - 10)
-                    end = min(len(content), pos + len(test_case["expected_not_contains"]) + 10)
-                    print(f"  Context: {repr(content[start:end])}")