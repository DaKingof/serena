--- test/serena/test_replace_regex_tool.py	(revision Before)
+++ test/serena/test_replace_regex_tool.py	(revision After)
@@ -1,81 +1,71 @@
+import json
+import logging
 import os
 import re
 import tempfile
+from pathlib import Path
 
 import pytest
 
+from serena.agent import SerenaAgent
+from serena.config.serena_config import ProjectConfig, RegisteredProject, SerenaConfig
+from serena.project import Project
 from serena.tools import SUCCESS_RESULT
 from serena.tools.file_tools import ReplaceRegexTool
-
-
-class MockProject:
-    def __init__(self, root_dir):
-        self.root_dir = root_dir
-        self.project_root = root_dir
-        self.project_config = MockProjectConfig()
-
-    def validate_relative_path(self, path):
-        return True
-
-    def read_file(self, path):
-        with open(os.path.join(self.root_dir, path)) as f:
-            return f.read()
-
-    def is_ignored_path(self, path):
-        return False
-
-
-class MockProjectConfig:
-    def __init__(self):
-        self.encoding = "utf-8"
+from solidlsp.ls_config import Language
 
 
-class MockAgent:
-    def __init__(self, project):
-        self.project = project
-        self._active_project = project
-        self.lines_read = None
-        self.serena_config = None
-
-    def get_active_project_or_raise(self):
-        return self.project
-
-    def get_active_project(self):
-        return self.project
-
-    def is_using_language_server(self):
-        return False
-
-    def record_tool_usage_if_enabled(self, *args, **kwargs):
-        pass
-
-    def issue_task(self, task, name):
-        from concurrent.futures import Future
-
-        future = Future()
-        future.set_result(task())
-        return future
-
-
-class TestReplaceRegexTool:
-    @pytest.fixture
-    def setup(self):
-        # Create a temporary directory for testing
-        with tempfile.TemporaryDirectory() as temp_dir:
-            # Create a test file
-            test_file_path = os.path.join(temp_dir, "test_file.py")
-            with open(test_file_path, "w") as f:
-                f.write("print(f'Some text')\n")
-                f.write("print(f'Another line')\n")
+@pytest.fixture
+def serena_config():
+    """Create an in-memory configuration for tests with a temporary directory."""
+    # Create a temporary directory for testing
+    with tempfile.TemporaryDirectory() as temp_dir:
+        # Create a Project instance for the temporary directory
+        project_name = "test_repo_temp"
+        project = Project(
+            project_root=temp_dir,
+            project_config=ProjectConfig(
+                project_name=project_name,
+                language=Language.PYTHON,  # Using Python as the language
+                ignored_paths=[],
+                excluded_tools=set(),
+                read_only=False,
+                ignore_all_files_in_gitignore=True,
+                initial_prompt="",
+                encoding="utf-8",
+            ),
+        )
+        
+        # Create SerenaConfig with the project
+        config = SerenaConfig(gui_log_window_enabled=False, web_dashboard=False, log_level=logging.ERROR)
+        config.projects = [RegisteredProject.from_project_instance(project)]
+        
+        yield config, temp_dir
+
+
+@pytest.fixture
+def serena_agent(serena_config):
+    """Create a SerenaAgent instance for testing."""
+    config, _ = serena_config
+    return SerenaAgent(project="test_repo_temp", serena_config=config)
+
+
+class TestReplaceRegexTool:
+    @pytest.fixture
+    def setup(self, serena_agent, serena_config):
+        """Setup test files and return the tool for testing."""
+        _, temp_dir = serena_config
+        
+        # Create a test file
+        test_file_path = os.path.join(temp_dir, "test_file.py")
+        with open(test_file_path, "w") as f:
+            f.write("print(f'Some text')\n")
+            f.write("print(f'Another line')\n")
 
-            # Setup mock project and agent
-            project = MockProject(temp_dir)
-            agent = MockAgent(project)
-
-            # Create the tool
-            tool = ReplaceRegexTool(agent)
+        # Create the tool
+        tool = serena_agent.get_tool(ReplaceRegexTool)
 
-            yield temp_dir, "test_file.py", tool
+        yield temp_dir, "test_file.py", tool
 
     def test_replace_with_newline(self, setup):
         """Test replacing text with a string containing newline escape sequences."""
@@ -249,3 +239,209 @@
         assert "print(f'\\n   Confidence Calculation Breakdown:')" in content
         # This is what we don't want to see - a literal newline in the string
         assert "print(f'\n   Confidence" not in content
+        
+    def test_regex_replacement_variations(self, setup):
+        """Test different variations of regex replacement with newlines."""
+        temp_dir, test_file_path, tool = setup
+        
+        # Create a test file
+        test_file = os.path.join(temp_dir, "regex_variations.py")
+        original_text = "print(f'Some text')"
+        with open(test_file, "w") as f:
+            f.write(original_text + "\n")
+            
+        # Test 1: Using a replacement string with \n
+        result1 = tool.apply(
+            relative_path="regex_variations.py",
+            regex=r"print\(f'Some text'\)",
+            repl=r"print(f'\n    Some more detailed text')",
+        )
+        
+        assert result1 == SUCCESS_RESULT
+        
+        with open(test_file) as f:
+            content1 = f.read()
+            
+        # The newline should be preserved as \n, not converted to a literal newline
+        assert "print(f'\\n    Some more detailed text')" in content1
+        assert "print(f'\n    Some" not in content1
+        
+        # Reset the file
+        with open(test_file, "w") as f:
+            f.write(original_text + "\n")
+            
+        # Test 2: Using a replacement string with literal newline
+        result2 = tool.apply(
+            relative_path="regex_variations.py",
+            regex=r"print\(f'Some text'\)",
+            repl="print(f'\n    Some more detailed text')",
+        )
+        
+        assert result2 == SUCCESS_RESULT
+        
+        with open(test_file) as f:
+            content2 = f.read()
+            
+        # The newline should be preserved as \n, not converted to a literal newline
+        assert "print(f'\\n    Some more detailed text')" in content2
+        assert "print(f'\n    Some" not in content2
+        
+        # Reset the file
+        with open(test_file, "w") as f:
+            f.write(original_text + "\n")
+            
+        # Test 3: Using a replacement string with double backslash
+        result3 = tool.apply(
+            relative_path="regex_variations.py",
+            regex=r"print\(f'Some text'\)",
+            repl=r"print(f'\\n    Some more detailed text')",
+        )
+        
+        assert result3 == SUCCESS_RESULT
+        
+        with open(test_file) as f:
+            content3 = f.read()
+            
+        # The double backslash should be preserved
+        assert "print(f'\\n    Some more detailed text')" in content3
+        
+    def test_edge_cases(self, setup):
+        """Test various edge cases for the ReplaceRegexTool."""
+        temp_dir, _, tool = setup
+        
+        # Define test cases
+        test_cases = [
+            {
+                "name": "Test 1: Basic newline escape sequence",
+                "content": "print('Hello')",
+                "regex": r"print\('Hello'\)",
+                "repl": r"print(f'\n    World')",
+                "expected_contains": r"print(f'\\n    World')",
+                "expected_not_contains": r"print(f'\n"
+            },
+            {
+                "name": "Test 2: Already escaped newline",
+                "content": "print('Hello')",
+                "regex": r"print\('Hello'\)",
+                "repl": r"print(f'\\n    World')",
+                "expected_contains": r"print(f'\\n    World')",
+                "expected_not_contains": r"print(f'\n"
+            },
+            {
+                "name": "Test 3: Double escaped newline",
+                "content": "print('Hello')",
+                "regex": r"print\('Hello'\)",
+                "repl": r"print(f'\\\\n    World')",
+                "expected_contains": r"print(f'\\\\n    World')",
+                "expected_not_contains": r"print(f'\n"
+            },
+            {
+                "name": "Test 4: Mixed escape sequences",
+                "content": "print('Hello')",
+                "regex": r"print\('Hello'\)",
+                "repl": r"print(f'\n\t    World\r\n')",
+                "expected_contains": r"print(f'\\n\\t    World\\r\\n')",
+                "expected_not_contains": r"print(f'\n"
+            },
+            {
+                "name": "Test 5: Newline in JSON string format",
+                "content": "print('Hello')",
+                "regex": r"print\('Hello'\)",
+                "repl": "print(f'\\n    World')",
+                "expected_contains": r"print(f'\\n    World')",
+                "expected_not_contains": r"print(f'\n"
+            },
+            {
+                "name": "Test 6: Literal newline in string",
+                "content": "print('Hello')",
+                "regex": r"print\('Hello'\)",
+                "repl": "print(f'\n    World')",
+                "expected_contains": r"print(f'\\n    World')",
+                "expected_not_contains": r"print(f'\n"
+            },
+            {
+                "name": "Test 7: Multiple newlines in complex string",
+                "content": "print('Hello')",
+                "regex": r"print\('Hello'\)",
+                "repl": "if (condition) {\n    print('Line 1');\n    print('Line 2');\n}",
+                "expected_contains": "if (condition) {",
+                "expected_not_contains": None  # We expect literal newlines in this case
+            },
+            {
+                "name": "Test 8: Newline in f-string with indentation",
+                "content": "                  print(f'Some text')",
+                "regex": r"print\(f'Some text'\)",
+                "repl": r"print(f'\n   Confidence Calculation Breakdown:')",
+                "expected_contains": r"print(f'\\n   Confidence Calculation Breakdown:')",
+                "expected_not_contains": r"print(f'\n"
+            },
+            {
+                "name": "Test 9: Exact scenario from issue description",
+                "content": "    *this >> wTag;",
+                "regex": r"\*this >> wTag;",
+                "repl": """    // Get file position BEFORE reading
+    long preReadPos = -1;
+    if (m_pFile) {
+        preReadPos = m_pFile->GetPosition();
+    }
+    *this >> wTag;
+    fprintf(stderr, "DEBUG: ReadClass at file pos 0x%lX, read wTag=0x%04X\\n", preReadPos, wTag);""",
+                "expected_contains": "DEBUG: ReadClass at file pos",
+                "expected_not_contains": None  # We expect literal newlines in this case
+            },
+            {
+                "name": "Test 10: JSON-style string with newline escape sequence",
+                "content": "                  print(f'Some text')",
+                "regex": r"print\(f'Some text'\)",
+                "repl": "print(f'\\n    Confidence Calculation Breakdown:')",
+                "expected_contains": r"print(f'\\n    Confidence Calculation Breakdown:')",
+                "expected_not_contains": r"print(f'\n"
+            },
+            {
+                "name": "Test 11: Multi-line JSON object from issue description",
+                "content": "                  print(f'Some text')",
+                "regex": r"print\(f'Some text'\)",
+                "repl": "    // Get file position BEFORE reading\n    long preReadPos = -1;\n    if (m_pFile) {\n        preReadPos = m_pFile->GetPosition();\n    }\n    \n    *this >> wTag;\n    \n    fprintf(stderr, \"DEBUG: ReadClass at file pos 0x%lX, read wTag=0x%04X\\n\", preReadPos, wTag);",
+                "expected_contains": "DEBUG: ReadClass at file pos",
+                "expected_not_contains": None  # We expect literal newlines in this case
+            }
+        ]
+        
+        for i, test_case in enumerate(test_cases):
+            # Create a test file
+            test_file = os.path.join(temp_dir, f"test_file_{i}.txt")
+            with open(test_file, "w") as f:
+                f.write(test_case["content"])
+            
+            # Apply the replacement
+            result = tool.apply(
+                relative_path=f"test_file_{i}.txt",
+                regex=test_case["regex"],
+                repl=test_case["repl"],
+            )
+            
+            assert result == SUCCESS_RESULT, f"Failed on test case: {test_case['name']}"
+            
+            # Read the file and check the content
+            with open(test_file, "r") as f:
+                content = f.read()
+            
+            # Check if the content contains the expected string
+            if test_case["expected_contains"]:
+                assert test_case["expected_contains"] in content, f"Expected string not found in test case: {test_case['name']}"
+            
+            # Check if the content does not contain the unexpected string
+            if test_case["expected_not_contains"]:
+                assert test_case["expected_not_contains"] not in content, f"Unexpected string found in test case: {test_case['name']}"
+            
+            # For string tests, check if there's a literal newline in the string
+            if "print(f'" in content and test_case["expected_not_contains"]:
+                # Find the position of the opening quote
+                start_pos = content.find("print(f'") + len("print(f'")
+                # Find the position of the closing quote
+                end_pos = content.find("')", start_pos)
+                # Extract the string content
+                string_content = content[start_pos:end_pos]
+                
+                # Check if there's a literal newline in the string
+                assert "\n" not in string_content, f"String contains literal newline in test case: {test_case['name']}"
