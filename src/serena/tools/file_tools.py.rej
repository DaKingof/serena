--- src/serena/tools/file_tools.py	(revision Before)
+++ src/serena/tools/file_tools.py	(revision After)
@@ -188,8 +188,64 @@
             original_content = context.get_original_content()
             
             # Process the replacement string to handle escape sequences properly
-            # This ensures that escape sequences like \n are preserved as-is in the output
-            processed_repl = repl.replace('\\n', '\\\\n').replace('\\t', '\\\\t').replace('\\r', '\\\\r')
+            # This ensures that escape sequences are preserved as-is in the output and not
+            # interpreted as literal characters (e.g., \n should remain as \n, not become a newline)
+            # 
+            # The issue was that escape sequences in replacement strings were being interpreted
+            # literally when they should be preserved as-is. For example, '\n' was becoming a literal
+            # newline character, breaking string literals across multiple lines.
+            #
+            # This fix handles all types of escape sequences:
+            # - Backreferences (\1, \2, etc.) are preserved as-is
+            # - Common escape sequences (\n, \t, etc.) are double-escaped to prevent interpretation
+            # - Hex and octal escape sequences are double-escaped
+            # - Escaped backslashes (\\) are preserved as-is
+            # - Other backslashes are escaped
+            def escape_backslashes(s):
+                # Create a list to store parts of the string (either escaped sequences or regular text)
+                parts = []
+                i = 0
+                while i < len(s):
+                    # Handle backreferences (\1, \2, etc.) - preserve these as-is
+                    if s[i] == '\\' and i + 1 < len(s) and s[i+1].isdigit():
+                        # This is a backreference, keep it as is
+                        parts.append(s[i:i+2])
+                        i += 2
+                    # Handle escape sequences (\n, \t, etc.) - double-escape these
+                    elif s[i] == '\\' and i + 1 < len(s) and s[i+1] in 'nrtbfv':
+                        # This is an escape sequence, double-escape it
+                        parts.append('\\' + s[i:i+2])
+                        i += 2
+                    # Handle hex escape sequences (\x00, etc.)
+                    elif s[i] == '\\' and i + 3 < len(s) and s[i+1] == 'x' and s[i+2:i+4].isalnum():
+                        # This is a hex escape sequence, double-escape it
+                        parts.append('\\' + s[i:i+4])
+                        i += 4
+                    # Handle octal escape sequences (\000, etc.)
+                    elif s[i] == '\\' and i + 1 < len(s) and s[i+1] in '01234567':
+                        # Determine the length of the octal sequence (1-3 digits)
+                        j = i + 2
+                        while j < len(s) and j < i + 4 and s[j] in '01234567':
+                            j += 1
+                        # This is an octal escape sequence, double-escape it
+                        parts.append('\\' + s[i:j])
+                        i = j
+                    # Handle escaped backslashes (\\) - preserve these as-is
+                    elif s[i] == '\\' and i + 1 < len(s) and s[i+1] == '\\':
+                        parts.append(s[i:i+2])
+                        i += 2
+                    # Handle other backslashes - escape them
+                    elif s[i] == '\\':
+                        parts.append('\\\\')
+                        i += 1
+                    # Regular character
+                    else:
+                        parts.append(s[i])
+                        i += 1
+                
+                return ''.join(parts)
+            
+            processed_repl = escape_backslashes(repl)
             
             updated_content, n = re.subn(regex, processed_repl, original_content, flags=re.DOTALL | re.MULTILINE)
             if n == 0:
